#!/usr/bin/env python3
"""Listens to `docker system events` and sents container stop/start events to mqtt.
"""
import atexit
import json
import queue
import re
import string
from os import environ
from socket import gethostname
from subprocess import run, Popen, PIPE
from threading import Thread
from time import sleep, time

import paho.mqtt.client

__version__ = "2.0.1"

DEBUG = environ.get('DEBUG', '1') == '1'
DESTROYED_CONTAINER_TTL = int(environ.get('DESTROYED_CONTAINER_TTL', 24*60*60))
HOMEASSISTANT_PREFIX = environ.get('HOMEASSISTANT_PREFIX', 'homeassistant')
DOCKER2MQTT_HOSTNAME = environ.get('DOCKER2MQTT_HOSTNAME', gethostname())
MQTT_CLIENT_ID = environ.get('MQTT_CLIENT_ID', 'docker2mqtt')
MQTT_USER = environ.get('MQTT_USER', '')
MQTT_PASSWD = environ.get('MQTT_PASSWD', '')
MQTT_HOST = environ.get('MQTT_HOST', 'localhost')
MQTT_PORT = int(environ.get('MQTT_PORT', '1883'))
MQTT_TIMEOUT = int(environ.get('MQTT_TIMEOUT', '30'))
MQTT_TOPIC_PREFIX = environ.get('MQTT_TOPIC_PREFIX', 'docker')
MQTT_QOS = int(environ.get('MQTT_QOS', 1))
MQTT_ATTRIBUTE = int(environ.get('MQTT_ATTRIBUTE',0))
DISCOVERY_TOPIC = f'{HOMEASSISTANT_PREFIX}/binary_sensor/{MQTT_TOPIC_PREFIX}/{DOCKER2MQTT_HOSTNAME}_{{}}/config'
WATCHED_EVENTS = ('create', 'destroy', 'die', 'pause', 'rename', 'start', 'stop', 'unpause')
STATS = environ.get('STATS','1')
EVENTS = environ.get('EVENTS','1')

known_containers = {}
pending_destroy_operations = {}
docker_events_cmd = ['docker', 'events', '-f', 'type=container', '--format', '{{json .}}']
docker_ps_cmd = ['docker', 'ps', '-a', '--format', '{{json .}}']
#docker_stats_cmd = ['docker','stats','--format','{\"container\":\"{{ .Name }}\",\"memory\":{\"raw\":\"{{ .MemUsage }}\",\"percent\":\"{{ .MemPerc }}\"},\"cpu\":\"{{ .CPUPerc }}\"}']
docker_stats_cmd = ['docker','stats','--format','{{json .}}']
invalid_ha_topic_chars = re.compile(r'[^a-zA-Z0-9_-]')


@atexit.register
def mqtt_disconnect():
    """Called by atexit to make sure we send our last_will message.
    """
    mqtt.publish(f'{MQTT_TOPIC_PREFIX}/{DOCKER2MQTT_HOSTNAME}/status', 'offline', qos=MQTT_QOS, retain=True)
    mqtt.disconnect()
    sleep(1)
    mqtt.loop_stop()


def mqtt_send(topic, payload, retain=False):
    try:
        if DEBUG:
            print(f'Sending to MQTT: {topic}: {payload}')
        mqtt.publish(topic, payload=payload, qos=MQTT_QOS, retain=retain)

    except Exception as e:
        print(f'MQTT Publish Failed: {e}')


def register_container(container_entry):
    """
    """
    known_containers[container_entry['name']] = container_entry
    registration_topic = DISCOVERY_TOPIC.format(invalid_ha_topic_chars.sub('_', container_entry['name']))
    registration_packet = {
        'name': f"{MQTT_TOPIC_PREFIX.title()} {container_entry['name']}",
        'unique_id': f'{MQTT_TOPIC_PREFIX}_{DOCKER2MQTT_HOSTNAME}_{registration_topic}',
        'availability_topic': f'{MQTT_TOPIC_PREFIX}/{DOCKER2MQTT_HOSTNAME}/status',
        'payload_available': 'online',
        'payload_not_available': 'offline',
        'state_topic': f'{MQTT_TOPIC_PREFIX}/{DOCKER2MQTT_HOSTNAME}/{container_entry["name"]}',
        'value_template': '{{ value_json.state }}',
        'payload_on': 'on',
        'payload_off': 'off',
        'device_class': 'connectivity',
        'json_attributes_topic': f'{MQTT_TOPIC_PREFIX}/{DOCKER2MQTT_HOSTNAME}/{container_entry["name"]}',
    }
    mqtt_send(registration_topic, json.dumps(registration_packet), retain=True)
    if MQTT_ATTRIBUTE == 0:
        mqtt_send(f'{MQTT_TOPIC_PREFIX}/{DOCKER2MQTT_HOSTNAME}/{container_entry["name"]}', json.dumps(container_entry), retain=True)
    else:
        #MQTT topic per field - works for openhab better
        for entry in container_entry:
            #print("================= entry")
            #print(entry)
            mqtt_send(f'{MQTT_TOPIC_PREFIX}/{DOCKER2MQTT_HOSTNAME}/{container_entry["name"]}/{entry}',container_entry[entry],retain=True)


def readline_thread():
    """Run docker events and continually read lines from it.
    """
    with Popen(docker_events_cmd, stdout=PIPE, text=True) as proc:
        while True:
            docker_events.put(proc.stdout.readline())

def readline_stats_thread():
    """Run docker events and continually read lines from it.
    """
    try:
        print("STATS: STARTING STATS THREAD")
        print(docker_stats_cmd)
        with Popen(docker_stats_cmd, stdout=PIPE, text=True) as proc2:
            while True:
                docker_stats.put(proc2.stdout.readline())
    except Exception as ex:
        print("Error Running stats thread: " + str(ex))
        pass

def stat_to_value(stat,container,matches):
    """Converts a regex matches to two values, ie used and limit for memory
    """
    usedsymbol = ""
    limitsymbol = ""
    used = 0
    limit = 0

    print("STATS %s: %s Found matching regex, getting used symbol" % (stat,container))
    usedsymbol = matches.group('usedsymbol')
    print("STATS %s: %s Used Symbol %s" % (stat,container,usedsymbol))
    limitsymbol = matches.group('limitsymbol')
    print("STATS %s: %s Limit Symbol %s" % (stat,container,limitsymbol))
    used = float(matches.group('used'))
    if (usedsymbol == "GiB"): used = used * 1024
    if (usedsymbol == "GB"): used = used * 1024
    if (usedsymbol == "kB"): used = used / 1024
    if (usedsymbol == "B"): used = used / 1024 / 1024
    print("STATS %s: %s Used %f Mb" % (stat,container,used))
    limit = float(matches.group('limit'))
    if (limitsymbol == "GiB"): limit = limit * 1024
    if (limitsymbol == "GB"): limit = limit * 1024
    if (limitsymbol == "kB"): limit = limit / 1024
    if (limitsymbol == "B"): limit = limit / 1024 /1024
    print("STATS %s: %s Limit %f Mb" % (stat,container,limit))
    print("STATS %s: Stat for container %s is %f.1 MB from %f.1 MB" % (stat,container,used,limit))
    return used,limit

if __name__ == '__main__':
    # Setup MQTT
    mqtt = paho.mqtt.client.Client()
    mqtt.username_pw_set(username=MQTT_USER,password=MQTT_PASSWD)
    mqtt.will_set(f'{MQTT_TOPIC_PREFIX}/{DOCKER2MQTT_HOSTNAME}/status', 'offline', qos=MQTT_QOS, retain=True)
    mqtt.connect(MQTT_HOST, MQTT_PORT, MQTT_TIMEOUT)
    mqtt.loop_start()
    mqtt_send(f'{MQTT_TOPIC_PREFIX}/{DOCKER2MQTT_HOSTNAME}/status', 'online', retain=True)

    numcontainers = 0
    # Register containers with HA
    docker_ps = run(docker_ps_cmd, stdout=PIPE, text=True)
    for line in docker_ps.stdout.splitlines():
        numcontainers = numcontainers + 1
        container_status = json.loads(line)
        print("Adding container: %s length: %s" % (container_status['Names'],numcontainers))

        if 'Paused' in container_status['Status']:
            status_str = 'paused'
            state_str = 'off'
        elif 'Up' in container_status['Status']:
            status_str = 'running'
            state_str = 'on'
        else:
            status_str = 'stopped'
            state_str = 'off'
        
        register_container({
            'name': container_status['Names'],
            'image': container_status['Image'],
            'status': status_str,
            'state': state_str
        })

    # Start the docker events thread
    if EVENTS == '1':
        docker_events = queue.Queue(maxsize=numcontainers)
        docker_events_t = Thread(target=readline_thread, daemon=True)
        docker_events_t.start()
    
     
    if (STATS == '1'):
        print("Starting stats thread")
        docker_stats = queue.Queue(maxsize=numcontainers)
        docker_stats_t = Thread(target=readline_stats_thread, daemon=True)
        docker_stats_t.start()
        print("Starting stats started")

    # Loop and wait for new events
    while True:
        # Collect and process an event from `docker events`
        try:
            print("Looking for line events")
            line = docker_events.get(timeout=1)
            print("After line events: %s" % docker_events.qsize() )
        except queue.Empty:
            # No data right now, just move along.
            print ("Line continue")
            pass
        
        print("Looking for line stats")
        try:
            linestats = docker_stats.get(timeout=1)
            print(linestats)
            print("Stats length: %s" % docker_stats.qsize())
        except queue.Empty:
            # No data right now, just move along.
            continue

        if docker_events.qsize() > 0:
            print ("EVENT:Have an event to process")
            try:
                if line:
                    event = json.loads(line)
                    print(event)
                    if event['status'] not in WATCHED_EVENTS:
                        print("EVENT: Not a watched event: %s" % event['status'])
                        continue

                    container = event['Actor']['Attributes']['name']

                    if event['status'] == 'create':
                        # Cancel any previous pending destroys and add this to known_containers.
                        print(f'Container {container} has been created.')
                        if container in pending_destroy_operations:
                            print(f'Removing pending delete for {{container}}.')
                            del(pending_destroy_operations[container])

                        register_container({
                            'name': container,
                            'image': event['from'],
                            'status': 'created',
                            'state': 'off'
                        })

                    elif event['status'] == 'destroy':
                        # Add this container to pending_destroy_operations.
                        print(f'Container {container} has been destroyed.')
                        pending_destroy_operations[container] = time()
                        known_containers[container]['status'] = 'destroyed'
                        known_containers[container]['state'] = 'off'

                    elif event['status'] == 'die':
                        print(f'Container {container} has stopped.')
                        known_containers[container]['status'] = 'stopped'
                        known_containers[container]['state'] = 'off'

                    elif event['status'] == 'pause':
                        print(f'Container {container} has paused.')
                        known_containers[container]['status'] = 'paused'
                        known_containers[container]['state'] = 'off'

                    elif event['status'] == 'rename':
                        old_name = event['Actor']['Attributes']['oldName']
                        if old_name.startswith('/'):
                            old_name = old_name[1:]
                        print(f'Container {old_name} renamed to {container}.')
                        mqtt_send(f'{HOMEASSISTANT_PREFIX}/binary_sensor/{MQTT_TOPIC_PREFIX}/{old_name}/config', '', retain=True)
                        mqtt_send(f'{MQTT_TOPIC_PREFIX}/{DOCKER2MQTT_HOSTNAME}/{old_name}', '', retain=True)
                        register_container({
                            'name': container,
                            'image': known_containers[old_name]['image'],
                            'status': known_containers[old_name]['status'],
                            'state': known_containers[old_name]['state']
                        })
                        del(known_containers[old_name])

                    elif event['status'] == 'start':
                        print(f'Container {container} has started.')
                        known_containers[container]['status'] = 'running'
                        known_containers[container]['state'] = 'on'

                    elif event['status'] == 'unpause':
                        print(f'Container {container} has unpaused.')
                        known_containers[container]['status'] = 'running'
                        known_containers[container]['state'] = 'on'

                    else:
                        # Don't send an MQTT packet if nothing has changed
                        continue
                    #if event['status'] == 'create':

                    if MQTT_ATTRIBUTE == 0:
                        print("EVENT: Sending mqtt payload")
                        mqtt_send(f'{MQTT_TOPIC_PREFIX}/{DOCKER2MQTT_HOSTNAME}/{container}', json.dumps(known_containers[container]), retain=True)
                    else:
                        #MQTT topic per field - works for openhab better
                        for entry in known_containers[container]:
                            print ("Processing container: " + container)
                            #print (entry)
                            mqtt_send(f'{MQTT_TOPIC_PREFIX}/{DOCKER2MQTT_HOSTNAME}/{container}/{entry}',known_containers[container][entry],retain=True)
                    #if MQTT_ATTRIBUTE == 0:
                #if event:
            except Exception as eventEx:
                print("EVENTS: error parsing line: " + str(eventEx))
                print("EVENTS: ERROR parsing line: " + line)

        #if docker_events.qsize() > 0:

        #{"BlockIO":"408MB / 0B","CPUPerc":"0.03%","Container":"9460abca90f1","ID":"9460abca90f1","MemPerc":"22.84%","MemUsage":"9.137MiB / 40MiB","Name":"d2mqtt","NetIO":"882kB / 1.19MB","PIDs":"11"}

        if docker_stats.qsize() > 0:
            print("STATS: loading line as JSON: " + linestats)
            if linestats:
                linestats = ''.join([c for c in linestats if ord(c) > 31 or ord(c) == 9])
                linestats = linestats.lstrip('[2J[H')
                #print(':'.join(hex(ord(x))[2:] for x in linestats))
                #linestats = linestats.rstrip('\n').rstrip('\r').lstrip('\n').lstrip('\r').lstrip('[2J[H')
                #[2J[H
                try:
                    stat = json.loads(linestats)
                    #print("STATS: loaded json")
                    #print(stat)
                    container = stat['Name']
                    #"61.13MiB / 2.86GiB"
                    #regex = r"(?P<used>\d+?\.?\d+?)(?P<usedsymbol>[MG]iB)\s+\/\s(?P<limit>\d+?\.?\d+?)(?P<limitsymbol>[MG]iB)"
                    regex = r"(?P<used>.+?)(?P<usedsymbol>[kMG]?i?B)\s+\/\s(?P<limit>.+?)(?P<limitsymbol>[kMG]?i?B)"
                    print("STATS: Getting Memory from \"%s\" with \"%s\"" % (stat['MemUsage'], regex))
                    matches = re.match(regex, stat['MemUsage'], re.MULTILINE)
                    print("STATS after regex parse")
                    memmbused,memmblimit = stat_to_value("MEMORY",container,matches)
                    known_containers[container]['memoryused'] = memmbused
                    known_containers[container]['memorylimit'] = memmblimit

                    print("STATS: Getting NETIO from \"%s\" with \"%s\"" % (stat['NetIO'], regex))
                    matches = re.match(regex, stat['NetIO'], re.MULTILINE)
                    netinput,netoutput = stat_to_value("NETIO",container,matches)
                    known_containers[container]['netinput'] = netinput
                    known_containers[container]['netoutput'] = netoutput

                    print("STATS: Getting BLOCKIO from \"%s\" with \"%s\"" % (stat['BlockIO'], regex))
                    matches = re.match(regex, stat['BlockIO'], re.MULTILINE)
                    blockinput,blockoutput = stat_to_value("BLOCKIO",container,matches)
                    known_containers[container]['blockinput'] = blockinput
                    known_containers[container]['blockoutput'] = blockoutput

                    known_containers[container]['memory'] = stat['MemUsage']
                    known_containers[container]['cpu'] = stat['CPUPerc']
                    known_containers[container]['netio'] = stat['NetIO']
                    print("STATS: printing container")
                    print(known_containers[container])
                    if MQTT_ATTRIBUTE == 0:
                        print("EVENT: Sending mqtt payload")
                        mqtt_send(f'{MQTT_TOPIC_PREFIX}/{DOCKER2MQTT_HOSTNAME}/{container}', json.dumps(known_containers[container]), retain=True)
                    else:
                        #MQTT topic per field - works for openhab better
                        for entry in known_containers[container]:
                            print ("Processing container: " + container)
                            #print (entry)
                            mqtt_send(f'{MQTT_TOPIC_PREFIX}/{DOCKER2MQTT_HOSTNAME}/{container}/{entry}',known_containers[container][entry],retain=True)
                except Exception as ex:
                    print("STATS: error parsing linestats: " + str(ex))
                    print("STATS: ERROR parsing linestats: " + linestats)
                    print(':'.join(hex(ord(x))[2:] for x in linestats))
                    
                    pass
            else:
                print("empty")


            print ("STATS: %s" % linestats)
        #if docker_stats.qsize() > 0:
    #while True:


